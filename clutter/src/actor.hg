/* Copyright (C) 2007 The cluttermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <glibmm/object.h>
#include <pangomm/context.h>
#include <pangomm/layout.h>
#include <atkmm/object.h>
#include <cluttermm/action.h>
#include <cluttermm/actor-box.h>
#include <cluttermm/animation.h>
#include <cluttermm/animatable.h>
#include <cluttermm/color.h>
//#include <cluttermm/content.h>
#include <cluttermm/effect.h>
//#include <cluttermm/layout-manager.h>
#include <cluttermm/scriptable.h>
#include <cluttermm/shader.h>
#include <cluttermm/transition.h>
#include <cluttermm/types.h> // For Event*

_DEFS(cluttermm,clutter)
_PINCLUDE(glibmm/private/object_p.h)

#m4 _PUSH(SECTION_CC_PRE_INCLUDES)
#define CLUTTER_DISABLE_DEPRECATION_WARNINGS 1
#m4 _POP()

namespace Clutter
{

typedef ClutterMatrix Matrix;
typedef ClutterPaintVolume PaintVolume;

class Animation;
class Constraint;
class Content;
class LayoutManager;

_WRAP_ENUM(ActorAlign, ClutterActorAlign)
_WRAP_ENUM(ActorFlags, ClutterActorFlags)
_WRAP_ENUM(AllocationFlags, ClutterAllocationFlags)
_WRAP_ENUM(ContentRepeat, ClutterContentRepeat)
_WRAP_ENUM(ContentGravity, ClutterContentGravity)
_WRAP_ENUM(OffscreenRedirect, ClutterOffscreenRedirect)
_WRAP_ENUM(Orientation, ClutterOrientation)


/** Actor is the main display class in Clutter, and all objects displayed on the
 * screen are actors - including the stage that they are displayed on.  The
 * underlying basis of Clutter is that all actors are part of a scene graph, and
 * so are all children of a parent actor up to the Clutter::Stage they are
 * shown on.
 *
 * ## Actor Transformations ##
 * All objects have a position, size, and various transformations, which are
 * manipulated via methods in this class.  The transformations occur in a defined
 * order which is hard coded into Clutter:
 *
 *    1. translation by the origin of the “allocation” property
 *
 *    2. translation by the actor's “z-position” property
 *
 *    3. translation by the actor's “pivot-point” property
 *
 *    4. scaling by the “scale-x” and “scale-y” factors
 *
 *    5. rotation around the “rotation-angle-x” and “rotation-center-x”
 *
 *    6. rotation around the “rotation-angle-y” and “rotation-center-y”
 *
 *    7. rotation around the “rotation-angle-z” and “rotation-center-z”
 *
 *    8. negative translation by the “anchor-x” and “anchor-y” point.
 *
 *    9. negative translation by the actor's “pivot-point”
 *
 * ## Modifying an actor's geometry ##

 * Each actor has a bounding box or “allocation” which is either set by its parent
 * or explicitly through the set_position() and set_size() methods.
 * Each actor also has an implicit preferred size.

 * An actor’s preferred size can be defined by any subclass by overriding the
 * get_preferred_width() and the get_preferred_height() virtual functions,
 * or it can be explicitly set by using set_width() and set_height().

 * An actor’s position can be set explicitly by using set_x() and set_y();
 * the coordinates are relative to the origin of the actor’s parent.
 *
 * ## Managing actor children ##

 * Each actor can have multiple children, by calling add_child() to add a
 * new child actor, and remove_child() to remove an existing child.
 * Clutter::Actor will hold a reference on each child actor, which will be
 * released when the child is removed from its parent, or destroyed using destroy().
 *
 * When drawing children, the order they are added is the order they are drawn.
 * Use set_child_below_sibling(), set_child_above_sibling(), or set_child_at_index()
 * to put one actor above another.  It is also possible to retrieve a list of children
 * by using get_children(),
 * If you need to track additions of children to an Actor, use the “actor-added” signal;
 * similarly, to track removals of children from an Actor, use the “actor-removed” signal.
 *
 * There is still some legacy API in Cluttermm that indicates the previous method
 * of managing children; this required a separate Container to hold the actors in.
 * Since the Actor now is able to contain children, this is no longer required
 * and should not be used.
 *
 * ## Painting an actor ##
 *
 * There are four ways to paint an actor:
 *
 *    -   Fill in the actor with set_background_color()
 *
 *    -   Set a delegate Content as the value for the “content” property of the actor.
 *
 *    -   Override the paint_node() virtual function.
 *
 *    -   Override the paint() virtual function.
 *
 * Applying a Clutter::Color with set_background_color() will paint the colour
 * given over the rectangular allocation area for that actor.  If you
 * require a rectangular shape, this is sufficient.
 *
 * A Clutter::Content is a delegate object that takes over the painting operations of
 * one, or more actors. The Content painting will be performed on top of
 * the “background-color” of the actor, and before calling the actor's own
 * implementation of the paint_node() virtual function.  It keeps the Actor's
 * rectangular background, whether the entire background is drawn on or not.  The
 * two Content implementations available are Image (to paint an image loaded from
 * elsewhere) or Context, which provides a Cairo::Context to draw on.

 * The paint_node_vfunc() virtual function is invoked whenever an actor needs to be
 * painted. The implementation of the virtual function must only paint the contents
 * of the actor itself, and not the contents of its children, if the actor has any.
 * Overriding the paint_node_vfunc() virtual function and the pick_vfunc() virtual function
 * is the preferred method for creating an actor with a non-rectangular shape;
 * the paint_node() method paints the Actor, while the pick() method is used to
 * identify when an event signal ( e.g. signal_button_press_event) should be
 * passed to the actor.

 * The PaintNode passed to the paint_node() virtual function is the local root of the
 * render tree; any node added to it will be rendered at the correct position,
 * as defined by the actor's “allocation”.
 *
 * Overriding the paint() virtual function has previously been the best method
 * of creating a custom image on the actor surface.  This is now deprecated and
 * the paint() method should not be used.  Use the paint_node() method instead.
 *
 * ## Handling events on an Actor ##
 *
 * An Actor can receive and handle input device events, for instance
 * pointer events and key events, as long as its “reactive” property is set to TRUE.
 *
 * Once an actor has been determined to be the source of an event, Clutter will
 * traverse the scene graph from the top-level actor towards the event source,
 * emitting the “captured-event” signal on each ancestor until it reaches the
 * source; this phase is also called the "capture" phase. If the event propagation
 *  was not stopped, the graph is walked backwards, from the source actor to the
 * top-level, and the “event” signal is emitted, alongside eventual event-specific
 * signals like “button-press-event” or “motion-event”; this phase is also
 * called the "bubble" phase.
 *
 * At any point of the signal emission, signal handlers can stop the propagation
 *  through the scene graph by returning true; otherwise, they can continue the
 * propagation by returning false.
 *
 * ## Animation ##
 *
 * Animation is a core concept of modern user interfaces; Clutter provides a
 * complete and powerful animation framework that automatically tweens the
 * actor's state without requiring direct, frame by frame manipulation from your
 *  application code. You have two models at your disposal:
 *
 *    -   an implicit animation model
 *
 *    -   an explicit animation model
 *
 * The implicit animation model of Clutter assumes that all the changes in an
 * actor state should be gradual and asynchronous; Clutter will automatically
 * transition an actor's property change between the current state and the desired
 * one without manual intervention, if the property is defined to be animatable
 * in its documentation.
 *
 * By default, in the 1.0 API series, the transition happens with a duration of
 * zero milliseconds.  Implicit animation is an opt in feature to retain
 * backwards compatibility.
 *
 * Implicit animations depend on the current easing state; in order to use the
 * new default easing state for an actor you should call save_easing_state().
 * Implicit animations use a default duration of 250 milliseconds, and a default
 * easing mode of Clutter::EASE_OUT_CUBIC, unless you call set_easing_mode() and
 * set_easing_duration() after changing the easing state of the actor.
 *
 * @code
 *
 * 		// assume that the actor is currently positioned at (100, 100)
 * 		// store the current easing state and reset the new easing state to its default values
 *
 * 		actor->save_easing_state ();
 *
 * 		// change the actor's position
 *
 * 		actor->set_position ( 500, 500);
 *
 * 		// restore the previously saved easing state
 *
 * 		actor->restore_easing_state ();
 * @endcode
 *
 * The example above will trigger an implicit animation of the actor between its
 * current position to a new position.
 *
 * It is possible to animate multiple properties of an actor at the same time,
 * and you can animate multiple actors at the same time as well, for instance:
 *
 * @code
 * 		actor->save_easing_state ();
 *
 * 		// animate the actor's opacity and depth
 * 		actor->set_opacity ( 0);
 * 		actor->set_depth (-100);
 *
 * 		actor->restore_easing_state ();
 *
 * 		another_actor->save_easing_state ();
 *
 * 		// animate another actor's opacity
 * 		another_actor->set_opacity ( 255);
 * 		another_actor->set_depth (100);
 *
 * 		another_actor->restore_easing_state ();
 * @endcode
 *
 * Changing the easing state will affect all the following property transitions,
 * but will not affect existing transitions.
 *
 * It is important to note that if you modify the state on an animatable property
 * while a transition is in flight, the transition's final value will be updated,
 * as well as its duration and progress mode by using the current easing state;
 * for instance, in the following example:
 *
 * @code
 * 		actor->save_easing_state();
 *
 * 		actor->set_easing_duration(1000);
 *
 * 		actor->set_x(200);
 *
 * 		actor->restore_easing_state();
 *
 *
 * 		actor->save_easing_state();
 *
 * 		actor->set_easing_duration(500);
 *
 * 		actor->set_x(100);
 *
 * 		actor->restore_easing_state();
 *
 * @endcode
 *
 * the first call to actor->set_x() will begin a transition of the “x” property
 * from the current value to the value of 200 over a duration of one second; the
 * second call to actor->set_x() will change the transition's final value to 100
 * and the duration to 500 milliseconds.
 *
 * It is possible to receive a notification of the completion of an implicit
 * transition by using the “transition-stopped” signal, decorated with the
 * name of the property. In case you want to know when all the currently in
 * flight transitions are complete, use the “transitions-completed” signal instead.
 *
 * It is possible to retrieve the Transition used by the animatable
 * properties by using clutter_actor_get_transition() and using the property name
 * as the transition name.
 *
 * The explicit animation model :
 *
 * This model requires that you create a Transition object, and optionally set
 * the initial and final values.  The transition will not start unless you add
 * it to the Actor.
 *
 * @code
 *
 * 		auto transition = Clutter::PropertyTransition::create("opacity");
 *
 * 		transition->set_duration (3000);
 *
 * 		transition->set_repeat_count ( 2);
 *
 * 		transition->set_auto_reverse ( true );
 *
 * 		// this is required so that the correct parameter type can be deduced in the
 *
 * 		// set_from method:
 *
 * 		int from(255);
 *
 * 		transition->set_from (from);
 *
 * 		int to(0);
 *
 * 		transition->set_to(0);
 *
 * 		actor->add_transition("animate-opacity", transition);
 * @endcode
 *
 * The example above will animate the “opacity” property of an actor between fully
 * opaque and fully transparent, and back, over a span of 3 seconds. The animation
 * does not begin until it is added to the actor.
 *
 * The explicit animation API applies to all GObject properties, as well as the
 * custom properties defined through the ClutterAnimatable interface, regardless
 * of whether they are defined as implicitly animatable or not.
 *
 * The explicit animation API should also be used when using custom animatable
 * properties for Clutter::Action, Clutter::Constraint, and Clutter::Effect
 * instances associated to an actor.
 *
 * Finally, explicit animations are useful for creating animations that run
 * continuously.
 */

class Actor : public Glib::Object, public Scriptable, public Animatable
{
  _CLASS_GOBJECT(Actor, ClutterActor, CLUTTER_ACTOR, Glib::Object, GObject)
  _DERIVES_INITIALLY_UNOWNED()
  _IMPLEMENTS_INTERFACE(Scriptable)
  _IMPLEMENTS_INTERFACE(Animatable)

protected:
  _CTOR_DEFAULT()

public:

  _WRAP_CREATE()

  _WRAP_METHOD(void set_flags(ActorFlags flags), clutter_actor_set_flags)
  _WRAP_METHOD(void unset_flags(ActorFlags flags), clutter_actor_unset_flags)
  _WRAP_METHOD(ActorFlags get_flags() const, clutter_actor_get_flags)

  //TODO: Remove these now that there are properties instead?
  // Not at present; there are no accessors available.
  bool is_mapped() const;
  bool is_realized() const;
  bool is_visible() const;
  bool is_reactive() const;

  _IGNORE(clutter_actor_destroy)

  _WRAP_METHOD(void show(), clutter_actor_show)
  _WRAP_METHOD(void show_all(), clutter_actor_show_all, deprecated "Actors are visible by default.")
  _WRAP_METHOD(void hide(), clutter_actor_hide)
  _WRAP_METHOD(void hide_all(), clutter_actor_hide_all, deprecated "Using hide() on the actor will now prevent its children from being painted as well.")
  _WRAP_METHOD(void realize(), clutter_actor_realize)
  _WRAP_METHOD(void unrealize(), clutter_actor_unrealize)
  _WRAP_METHOD(void map(), clutter_actor_map)
  _WRAP_METHOD(void unmap(), clutter_actor_unmap)
  _WRAP_METHOD(void paint(), clutter_actor_paint)
  _WRAP_METHOD(void continue_paint(), clutter_actor_continue_paint)
  _WRAP_METHOD(void queue_redraw(), clutter_actor_queue_redraw)
  _WRAP_METHOD(void queue_relayout(), clutter_actor_queue_relayout)
  _IGNORE(clutter_actor_queue_redraw_with_clip) //internal.
  _IGNORE(clutter_actor_queue_relayout) //not for application code.
  _IGNORE(clutter_actor_should_pick_paint ) //not for application code.

  _WRAP_METHOD(bool has_overlaps(), clutter_actor_has_overlaps)

  _WRAP_METHOD(void set_content(const Glib::RefPtr<Content>& content), clutter_actor_set_content)

  _WRAP_METHOD(Glib::RefPtr<Content> get_content(), clutter_actor_get_content, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Content> get_content() const, clutter_actor_get_content, refreturn, constversion)

  _WRAP_METHOD(void set_content_gravity(ContentGravity gravity), clutter_actor_set_content_gravity)

  _WRAP_METHOD(ContentGravity get_content_gravity() const, clutter_actor_get_content_gravity)

  _WRAP_METHOD(void set_content_scaling_filters(ScalingFilter min_filter, ScalingFilter mag_filter), clutter_actor_set_content_scaling_filters)

#m4 _CONVERSION(`ScalingFilter&', `ClutterScalingFilter*', `(($2)&($3))')
  _WRAP_METHOD(void get_content_scaling_filters(ScalingFilter& min_filter, ScalingFilter& mag_filter), clutter_actor_get_content_scaling_filters)

  _WRAP_METHOD(void set_content_repeat(ContentRepeat repeat), clutter_actor_set_content_repeat)
  _WRAP_METHOD(ContentRepeat get_content_repeat() const, clutter_actor_get_content_repeat)

  ActorBox get_content_box() const;
  _IGNORE(clutter_actor_get_content_box)

#m4 dnl // Those are varargs convenience functions for C coders
  _IGNORE(clutter_actor_animate, clutter_actor_animate_with_alpha, clutter_actor_animate_with_timeline)

  //We ignore clutter_actor_destroy because it would break any existing RefPtr.
  _IGNORE(clutter_actor_destroy)

  _WRAP_METHOD(Glib::RefPtr<Pango::Context> get_pango_context(),
               clutter_actor_get_pango_context, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Pango::Context> get_pango_context() const,
               clutter_actor_get_pango_context, refreturn, constversion)
  _WRAP_METHOD(Glib::RefPtr<Pango::Context> create_pango_context(),
               clutter_actor_create_pango_context)

  _WRAP_METHOD(Glib::RefPtr<Pango::Layout> create_pango_layout(const Glib::ustring& text),
               clutter_actor_create_pango_layout)

  _IGNORE( clutter_actor_get_transform) //handcoded to allow returning the Matrix.

  /**
   * Returns the transformation matrix being used by the actor.
   * */
  Matrix get_transform() const;

  _WRAP_METHOD(void get_transformation_matrix(ClutterMatrix* matrix), clutter_actor_get_transformation_matrix, deprecated "Use get_transform() instead")
  _WRAP_METHOD(void set_transform(const Matrix& transform), clutter_actor_set_transform)
  _WRAP_METHOD(void set_child_transform(const Matrix& transform), clutter_actor_set_child_transform)

  _WRAP_METHOD(bool is_in_clone_paint() const, clutter_actor_is_in_clone_paint)

#m4 _INITIALIZATION(`ActorBox&',`ClutterActorBox', `$3 = Glib::wrap(&($4))')
  _WRAP_METHOD(bool get_paint_box(ActorBox& box{>>}), clutter_actor_get_paint_box)

  _WRAP_METHOD(bool has_pointer() const, clutter_actor_has_pointer)
  _WRAP_METHOD(void set_text_direction(TextDirection text_dir), clutter_actor_set_text_direction)
  _WRAP_METHOD(TextDirection get_text_direction() const, clutter_actor_get_text_direction)


  _WRAP_METHOD(Glib::RefPtr<Actor> get_stage(), clutter_actor_get_stage, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Actor> get_stage() const, clutter_actor_get_stage, refreturn, constversion)

  _WRAP_METHOD(void set_child_below_sibling(const Glib::RefPtr<Actor>& child, const Glib::RefPtr<Actor>& sibling), clutter_actor_set_child_below_sibling)
  _WRAP_METHOD(void set_child_above_sibling(const Glib::RefPtr<Actor>& child, const Glib::RefPtr<Actor>& sibling), clutter_actor_set_child_above_sibling)
  _WRAP_METHOD(void set_child_at_index(const Glib::RefPtr<Actor>& child, int index), clutter_actor_set_child_at_index)

#m4 _CONVERSION(`const Geometry&', `const ClutterGeometry*', `($3).gobj()')
  _WRAP_METHOD(void set_geometry(const Geometry& geometry), clutter_actor_set_geometry, deprecated "Use set_position() and set_size() instead.")

_DEPRECATE_IFDEF_START
  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_geometry)
  /**
   * @deprecated Use get_position() and get_size(), or get_allocation_geometry() instead.
   */
  Geometry get_geometry() const;
_DEPRECATE_IFDEF_END

  //_WRAP_METHOD(void get_coords(float *x_1, float *y_1, float *x_2, float *y_2) const, clutter_actor_get_coords)
  _WRAP_METHOD(void set_size(float width, float height), clutter_actor_set_size)
  _WRAP_METHOD(void get_position(float& x, float& y), clutter_actor_get_position)
  _WRAP_METHOD(void set_position(float x, float y), clutter_actor_set_position)
  //_WRAP_METHOD(void get_abs_position(float& x, float& y) const, clutter_actor_get_abs_position)
  _WRAP_METHOD(float get_width() const, clutter_actor_get_width)
  _WRAP_METHOD(float get_height() const, clutter_actor_get_height)
  _WRAP_METHOD(void set_width(float width), clutter_actor_set_width)
  _WRAP_METHOD(void set_height(float height), clutter_actor_set_height)

  _WRAP_METHOD(void set_x(float x), clutter_actor_set_x)
  _WRAP_METHOD(float get_x() const, clutter_actor_get_x)
  _WRAP_METHOD(void set_y(float y), clutter_actor_set_y)
  _WRAP_METHOD(float get_y() const, clutter_actor_get_y)
  _WRAP_METHOD(void set_z_position(float z_position), clutter_actor_set_z_position)
  _WRAP_METHOD(float get_z_position() const, clutter_actor_get_z_position)

 _WRAP_METHOD(void set_x_align(ActorAlign x_align), clutter_actor_set_x_align)
 _WRAP_METHOD(ActorAlign get_x_align() const, clutter_actor_get_x_align)
 _WRAP_METHOD(void set_y_align(ActorAlign y_align), clutter_actor_set_y_align)
 _WRAP_METHOD(ActorAlign get_y_align() const,clutter_actor_get_y_align)

  _WRAP_METHOD(bool get_x_expand() const, clutter_actor_get_x_expand)
  _WRAP_METHOD(void set_x_expand(bool expand = true), clutter_actor_set_x_expand)
  _WRAP_METHOD(bool get_y_expand() const, clutter_actor_get_y_expand)
  _WRAP_METHOD(void set_y_expand(bool expand = true), clutter_actor_set_y_expand)
  _WRAP_METHOD(bool needs_expand(Orientation orientation) const, clutter_actor_needs_expand)

  _WRAP_METHOD(void set_layout_manager(const Glib::RefPtr<LayoutManager>& manager), clutter_actor_set_layout_manager)

  /** Unset the layout manager.
   */
  void unset_layout_manager();

  _WRAP_METHOD(Glib::RefPtr<LayoutManager> get_layout_manager(), clutter_actor_get_layout_manager, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const LayoutManager> get_layout_manager() const, clutter_actor_get_layout_manager, refreturn, constversion)

  _WRAP_METHOD(void set_reactive(bool reactive = true), clutter_actor_set_reactive)
  _WRAP_METHOD(bool get_reactive() const, clutter_actor_get_reactive)
  _WRAP_METHOD(bool has_key_focus() const, clutter_actor_has_key_focus)


  _WRAP_METHOD(void set_rotation(RotateAxis axis, double angle, float x, float y, float z), clutter_actor_set_rotation, deprecated "Use set_rotation_angle() and set_pivot_point() instead.")
  _WRAP_METHOD(void set_z_rotation_from_gravity(double angle, Gravity gravity), clutter_actor_set_z_rotation_from_gravity, deprecated "Use set_rotation_angle() and set_pivot_point() instead.")
  _WRAP_METHOD(double get_rotation(RotateAxis axis, float& x, float& y, float& z) const, clutter_actor_get_rotation, deprecated "Use get_rotation_angle() and get_pivot_point() instead.")
  _WRAP_METHOD(Gravity get_z_rotation_gravity() const, clutter_actor_get_z_rotation_gravity, deprecated "Use the “pivot-point” instead of a Gravity.")
  _WRAP_METHOD(void set_opacity(guint8 opacity), clutter_actor_set_opacity)
  _WRAP_METHOD(guint8 get_opacity() const, clutter_actor_get_opacity)

  _WRAP_METHOD(void set_offscreen_redirect(OffscreenRedirect redirect) const,clutter_actor_set_offscreen_redirect)
  _WRAP_METHOD(OffscreenRedirect get_offscreen_redirect(), clutter_actor_get_offscreen_redirect)

  _WRAP_METHOD(void set_background_color(const Color& color), clutter_actor_set_background_color)

  /** Retrieves the color set using set_background_color().
   */
  Color get_background_color() const;
  _IGNORE(clutter_actor_get_background_color)

  _WRAP_METHOD(const PaintVolume* get_paint_volume() const, clutter_actor_get_paint_volume)
  _WRAP_METHOD(const PaintVolume* get_transformed_paint_volume(const Glib::RefPtr<Actor>& relative_to_ancestor{?}) const, clutter_actor_get_transformed_paint_volume)
  _WRAP_METHOD(const PaintVolume* get_default_paint_volume() const, clutter_actor_get_default_paint_volume)


  _WRAP_METHOD(void set_name(const gchar *name), clutter_actor_set_name)
  _WRAP_METHOD(Glib::ustring get_name() const, clutter_actor_get_name)
  _WRAP_METHOD(guint32 get_gid() const, clutter_actor_get_gid)
  _WRAP_METHOD(void set_clip(float xoff, float yoff, float width, float height), clutter_actor_set_clip)
  _WRAP_METHOD(void get_clip(float& xoff, float& yoff, float& width, float& height), clutter_actor_get_clip)
  _WRAP_METHOD(void set_clip_to_allocation(bool clip_set = true), clutter_actor_set_clip_to_allocation)
  _WRAP_METHOD(bool get_clip_to_allocation() const, clutter_actor_get_clip_to_allocation)
  _WRAP_METHOD(void remove_clip(), clutter_actor_remove_clip)
  _WRAP_METHOD(bool has_clip() const, clutter_actor_has_clip)

  #m4 _CONVERSION(`GList*',`std::vector< Glib::RefPtr<Actor> >',`Glib::ListHandler< Glib::RefPtr<Actor> >::list_to_vector($3, Glib::OWNERSHIP_SHALLOW)')
  _WRAP_METHOD(std::vector< Glib::RefPtr<Actor> > get_children(), clutter_actor_get_children)

  #m4 _CONVERSION(`GList*',`std::vector< Glib::RefPtr<const Actor> >',`Glib::ListHandler< Glib::RefPtr<const Actor> >::list_to_vector($3, Glib::OWNERSHIP_SHALLOW)')
  _WRAP_METHOD(std::vector< Glib::RefPtr<const Actor> > get_children() const, clutter_actor_get_children)

  _WRAP_METHOD(int get_n_children() const, clutter_actor_get_n_children)

  _WRAP_METHOD(Glib::RefPtr<Actor> get_child_at_index(int index), clutter_actor_get_child_at_index, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Actor> get_child_at_index(int index) const, clutter_actor_get_child_at_index, refreturn, constversion)

  _WRAP_METHOD(Glib::RefPtr<Actor> get_previous_sibling(), clutter_actor_get_previous_sibling, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Actor> get_previous_sibling() const, clutter_actor_get_previous_sibling, refreturn, constversion)

  _WRAP_METHOD(Glib::RefPtr<Actor> get_next_sibling(), clutter_actor_get_next_sibling, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Actor> get_next_sibling() const, clutter_actor_get_next_sibling, refreturn, constversion)

  _WRAP_METHOD(Glib::RefPtr<Actor> get_first_child(), clutter_actor_get_first_child, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Actor> get_first_child() const, clutter_actor_get_first_child, refreturn, constversion)

  _WRAP_METHOD(Glib::RefPtr<Actor> get_last_child(), clutter_actor_get_last_child, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Actor> get_last_child() const, clutter_actor_get_last_child, refreturn, constversion)

  _WRAP_METHOD(void set_parent(const Glib::RefPtr<Actor>& parent), clutter_actor_set_parent, deprecated "Use add_child() instead.")
  _WRAP_METHOD(Glib::RefPtr<Actor> get_parent(), clutter_actor_get_parent, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Actor> get_parent() const, clutter_actor_get_parent, refreturn, constversion)
  _WRAP_METHOD(void reparent(const Glib::RefPtr<Actor>& new_parent), clutter_actor_reparent, deprecated "Use remove_child() and add_child() instead.")
  _WRAP_METHOD(void unparent(), clutter_actor_unparent, deprecated "Use remove_child() instead.")
  _WRAP_METHOD(bool contains(const Glib::RefPtr<const Actor>& descendant) const, clutter_actor_contains)
  _WRAP_METHOD(void raise(const Glib::RefPtr<Actor>& below), clutter_actor_raise, deprecated "Use set_child_above_sibling() instead.")
  _WRAP_METHOD(void lower(const Glib::RefPtr<Actor>& above), clutter_actor_lower, deprecated "Use set_child_below_sibling() instead")
  _WRAP_METHOD(void raise_top (), clutter_actor_raise_top)
  _WRAP_METHOD(void lower_bottom(), clutter_actor_lower_bottom)

  _WRAP_METHOD(Glib::RefPtr<Shader> get_shader(), clutter_actor_get_shader, refreturn, deprecated "Use get_effect() instead.")
  _WRAP_METHOD(Glib::RefPtr<const Shader> get_shader() const, clutter_actor_get_shader, refreturn, constversion, deprecated "Use get_effect() instead.")
  _WRAP_METHOD(void set_shader(const Glib::RefPtr<Shader>& shader), clutter_actor_set_shader, deprecated "Use add_effect() instead.")

_DEPRECATE_IFDEF_START
  _WRAP_METHOD_DOCS_ONLY(clutter_actor_set_shader_param)
  /**
   * @deprecated Use ShaderEffect::set_uniform_value() instead."
   */
  template <class ParamType> void set_shader_param(const Glib::ustring& param, const ParamType& value);
_DEPRECATE_IFDEF_END
  _IGNORE(clutter_actor_set_shader_param_int, clutter_actor_set_shader_param_float)

  //_WRAP_METHOD_DOCS_ONLY(clutter_actor_get_paint_area)
  //ActorBox get_paint_area() const;
  _WRAP_METHOD(bool is_rotated() const, clutter_actor_is_rotated)
  _WRAP_METHOD(bool is_scaled() const, clutter_actor_is_scaled)

  _WRAP_METHOD(void set_pivot_point(float x, float y), clutter_actor_set_pivot_point)
  _WRAP_METHOD(void get_pivot_point(float& pivot_x, float& pivot_y) const, clutter_actor_get_pivot_point)
  _WRAP_METHOD(void set_pivot_point_z(float pivot_z), clutter_actor_set_pivot_point_z)
  _WRAP_METHOD(float get_pivot_point_z() const, clutter_actor_get_pivot_point_z)
  _WRAP_METHOD(void set_rotation_angle(RotateAxis axis, double angle), clutter_actor_set_rotation_angle)
  _WRAP_METHOD(double get_rotation_angle(RotateAxis axis) const, clutter_actor_get_rotation_angle)

  _WRAP_METHOD(void set_translation(float translate_x, float translate_y, float translate_z), clutter_actor_set_translation)
  _WRAP_METHOD(void get_translation(float& translate_x, float& translate_y, float& translate_z) const, clutter_actor_get_translation)

  _WRAP_METHOD(bool should_pick_paint() const, clutter_actor_should_pick_paint)

  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_allocation_vertices)
  void get_allocation_vertices(Vertex vertices[4]) const;

  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_allocation_vertices)
  void get_allocation_vertices(const Glib::RefPtr<Actor>& ancestor, Vertex vertices[4]) const;

  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_abs_allocation_vertices)
  void get_abs_allocation_vertices(Vertex vertices[4]) const;

  _WRAP_METHOD(void allocate_align_fill(const ActorBox& box,gdouble x_align, double y_align, bool x_fill, bool y_fill, AllocationFlags flags), clutter_actor_allocate_align_fill)

  _WRAP_METHOD(void set_allocation(const ActorBox& box, AllocationFlags flags), clutter_actor_set_allocation)

  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_allocation_box)
  ActorBox get_allocation_box() const;

  _WRAP_METHOD(void allocate(const ActorBox& box, AllocationFlags absolute_origin_changed = ALLOCATION_NONE), clutter_actor_allocate)

  //TODO: Make this protected?
  _WRAP_METHOD(void allocate_preferred_size(AllocationFlags absolute_origin_changed = ALLOCATION_NONE), clutter_actor_allocate_preferred_size)

  _WRAP_METHOD(void allocate_available_size(float x, float y, float available_width, float available_height, AllocationFlags flags = ALLOCATION_NONE), clutter_actor_allocate_available_size)

  _WRAP_METHOD(void apply_transform_to_point(const Vertex& point, Vertex& vertex) const, clutter_actor_apply_transform_to_point)
  _WRAP_METHOD(void transform_stage_point(float x, float y, float& x_out, float& y_out) const, clutter_actor_transform_stage_point)
#m4 _CONVERSION(`const Vertex&',`ClutterVertex*',`const_cast<ClutterVertex*>(($3).gobj())')
#m4 _CONVERSION(`Vertex&',`ClutterVertex*',`($3).gobj()')
  _WRAP_METHOD(void apply_relative_transform_to_point(const Glib::RefPtr<Actor>& ancestor, const Vertex& point, Vertex& vertex) const, clutter_actor_apply_relative_transform_to_point)
  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_allocation_vertices)
  void apply_relative_transform_to_point(const Vertex& point, Vertex& vertex) const;
  _WRAP_METHOD(void get_transformed_position(float& x, float& y) const, clutter_actor_get_transformed_position)

  Matrix get_child_transform() const;
  _IGNORE(clutter_actor_get_child_transform)

  _WRAP_METHOD(void get_transformed_size(float& width, float& height) const, clutter_actor_get_transformed_size)

  _WRAP_METHOD(void set_request_mode(RequestMode mode), clutter_actor_set_request_mode)
  _WRAP_METHOD(RequestMode get_request_mode() const, clutter_actor_get_request_mode)

  _WRAP_METHOD(void get_preferred_size(float& min_width_p, float& min_height_p, float& natural_width_p, float& natural_height_p) const, clutter_actor_get_preferred_size)
  _WRAP_METHOD(void get_preferred_width(float for_height, float& min_width_p, float& natural_width_p) const, clutter_actor_get_preferred_width)
  _WRAP_METHOD(void get_preferred_height(float for_width, float& min_height_p, float& natural_height_p) const, clutter_actor_get_preferred_height)
  _WRAP_METHOD(guint8 get_paint_opacity() const, clutter_actor_get_paint_opacity)
  _WRAP_METHOD(bool get_paint_visibility() const, clutter_actor_get_paint_visibility)
  _WRAP_METHOD(void move_anchor_point_from_gravity(Gravity gravity), clutter_actor_move_anchor_point_from_gravity, deprecated "Use “pivot-point” instead.")
  _WRAP_METHOD(void move_anchor_point(float anchor_x, float anchor_y), clutter_actor_move_anchor_point, deprecated "Use “pivot-point” instead.")

// IM: ClutterMargin.
  _IGNORE(clutter_actor_set_margin, clutter_actor_get_margin)
  _WRAP_METHOD(void set_margin_top(float margin), clutter_actor_set_margin_top)
  _WRAP_METHOD(float get_margin_top() const, clutter_actor_get_margin_top)
  _WRAP_METHOD(void set_margin_bottom(float margin), clutter_actor_set_margin_bottom)
  _WRAP_METHOD(float get_margin_bottom() const, clutter_actor_get_margin_bottom)
  _WRAP_METHOD(void set_margin_left(float margin), clutter_actor_set_margin_left)
  _WRAP_METHOD(float get_margin_left() const, clutter_actor_get_margin_left)
  _WRAP_METHOD(void set_margin_right(float margin), clutter_actor_set_margin_right)
  _WRAP_METHOD(float get_margin_right() const, clutter_actor_get_margin_right)
  /**
  * Convenience method for setting all margins at once.
  *
  * @param top The top margin
  * @param left the left margin
  * @param bottom The bottom margin
  * @param right The right margin.
  * */
  void set_margins(float top, float left, float bottom, float right);

  _WRAP_METHOD(bool get_fixed_position_set() const, clutter_actor_get_fixed_position_set)
  _WRAP_METHOD(void set_fixed_position_set(bool is_set), clutter_actor_set_fixed_position_set)

_DEPRECATE_IFDEF_START
  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_allocation_geometry)
  /**
   * @deprecated Use get_allocation_box() instead.
   */
  Geometry get_allocation_geometry() const;
_DEPRECATE_IFDEF_END

  _WRAP_METHOD(void set_depth(float depth), clutter_actor_set_depth, deprecated "Use set_z_position() instead.)
  _WRAP_METHOD(float get_depth() const, clutter_actor_get_depth, deprecated "Use get_z_position() instead.")
  _WRAP_METHOD(void set_scale(double scale_x, double scale_y), clutter_actor_set_scale)
  _WRAP_METHOD(void set_scale_z(double scale_z), clutter_actor_set_scale_z)
  _WRAP_METHOD(void set_scale_full(double scale_x, double scale_y, float center_x, float center_y), clutter_actor_set_scale_full, deprecated "Use set_pivot_point() to control the scale center.")
  _WRAP_METHOD(void set_scale_with_gravity(double scale_x, double scale_y, Gravity gravity), clutter_actor_set_scale_with_gravity, deprecated "Use set_pivot_point() to set the scale center using normalized coordinates instead.")
  _WRAP_METHOD(void get_scale(double& scale_x, double& scale_y) const, clutter_actor_get_scale)
  _WRAP_METHOD(double get_scale_z() const, clutter_actor_get_scale_z)
  _WRAP_METHOD(void get_scale_center(float& center_x, float& center_y) const, clutter_actor_get_scale_center, deprecated "Use get_pivot_point() instead.")
  _WRAP_METHOD(Gravity get_scale_gravity() const, clutter_actor_get_scale_gravity, deprecated "Use get_pivot_point() instead.")

  //_WRAP_METHOD(void get_abs_size(float& width, float& height) const, clutter_actor_get_abs_size)
  _WRAP_METHOD(void get_size(float& width, float& height) const, clutter_actor_get_size)
  _WRAP_METHOD(void move_by(float dx, float dy), clutter_actor_move_by)

  _WRAP_METHOD(bool event(const ClutterEvent* event, bool capture), clutter_actor_event)
  _WRAP_METHOD(static Glib::RefPtr<Actor> get_actor_by_gid(guint32 id), clutter_get_actor_by_gid, refreturn, deprecated "The ID is no longer used.")

  _WRAP_METHOD(void set_anchor_point(float anchor_x, float anchor_y), clutter_actor_set_anchor_point, deprecated "Use “pivot-point” instead.")
  _WRAP_METHOD(void get_anchor_point(float& anchor_x, float& anchor_y) const, clutter_actor_get_anchor_point, deprecated "Use “pivot-point” instead.")
  _WRAP_METHOD(void set_anchor_point_from_gravity(ClutterGravity gravity), clutter_actor_set_anchor_point_from_gravity, deprecated "Use “pivot-point” instead.")
  _WRAP_METHOD(Gravity get_anchor_point_gravity(), clutter_actor_get_anchor_point_gravity, deprecated "Use “pivot-point” instead.")

  _WRAP_METHOD(void grab_key_focus(), clutter_actor_grab_key_focus)

  _WRAP_METHOD(void add_child(const Glib::RefPtr<Actor>& child), clutter_actor_add_child)
  _WRAP_METHOD(void insert_child_above(const Glib::RefPtr<Actor>& child, const Glib::RefPtr<Actor>& sibling), clutter_actor_insert_child_above)
  _WRAP_METHOD(void insert_child_at_index(const Glib::RefPtr<Actor>& child, int index), clutter_actor_insert_child_at_index)
  _WRAP_METHOD(void insert_child_below(const Glib::RefPtr<Actor>& child, const Glib::RefPtr<Actor>& sibling), clutter_actor_insert_child_below)
  _WRAP_METHOD(void replace_child(const Glib::RefPtr<Actor>& old_child, const Glib::RefPtr<Actor>& new_child), clutter_actor_replace_child)

  _WRAP_METHOD(void remove_child(const Glib::RefPtr<Actor>& child), clutter_actor_remove_child )
  _WRAP_METHOD(void remove_all_children(), clutter_actor_remove_all_children )

   //deprecated
  _IGNORE(clutter_actor_animate, clutter_actor_animatev, clutter_actor_animate_with_timelinev, clutter_actor_animate_with_alphav)

  _WRAP_METHOD(Glib::RefPtr<Animation> get_animation(), clutter_actor_get_animation, refreturn, deprecated "Use the implicit transition for animatable properties in ClutterActor instead, and clutter_actor_get_transition() to retrieve the transition.")
  _WRAP_METHOD(Glib::RefPtr<const Animation> get_animation() const, clutter_actor_get_animation, refreturn, constversion, deprecated "Use the implicit transition for animatable properties in ClutterActor instead, and clutter_actor_get_transition() to retrieve the transition.")

  _WRAP_METHOD(void detach_animation(), clutter_actor_detach_animation)


  _WRAP_METHOD(void push_internal(), clutter_actor_push_internal, deprecated "All children of an actor are accessible through the ClutterActor API, and ClutterActor implements the ClutterContainer interface, so this function is only useful for legacy containers overriding the default implementation.")
  _WRAP_METHOD(void pop_internal(), clutter_actor_pop_internal, deprecated "All children of an actor are accessible through the ClutterActor API. This function is only useful for legacy containers overriding the default implementation of the ClutterContainer interface.")

  _WRAP_METHOD(bool has_allocation() const, clutter_actor_has_allocation)

  _WRAP_METHOD(Glib::RefPtr<Atk::Object> get_accessible(), clutter_actor_get_accessible, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Atk::Object> get_accessible() const, clutter_actor_get_accessible, refreturn, constversion)

  _WRAP_METHOD(void add_action(const Glib::RefPtr<Action>& action), clutter_actor_add_action)
  _WRAP_METHOD(void add_action(const Glib::ustring& name, const Glib::RefPtr<Action>& action), clutter_actor_add_action_with_name)
  _WRAP_METHOD(void remove_action(const Glib::RefPtr<Action>&action), clutter_actor_remove_action)
  _WRAP_METHOD(void remove_action(const Glib::ustring& name), clutter_actor_remove_action_by_name)

  _WRAP_METHOD(Glib::RefPtr<Action> get_action(const Glib::ustring& name), clutter_actor_get_action, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Action> get_action(const Glib::ustring& name) const, clutter_actor_get_action, refreturn, constversion)

  _WRAP_METHOD(void clear_actions(), clutter_actor_clear_actions)

  #m4 _CONVERSION(`GList*',`std::vector< Glib::RefPtr<Action> >',`Glib::ListHandler< Glib::RefPtr<Action> >::list_to_vector($3, Glib::OWNERSHIP_SHALLOW)')
  _WRAP_METHOD(std::vector< Glib::RefPtr<Action> > get_actions(), clutter_actor_get_actions)

  #m4 _CONVERSION(`GList*',`std::vector< Glib::RefPtr<const Action> >',`Glib::ListHandler< Glib::RefPtr<const Action> >::list_to_vector($3, Glib::OWNERSHIP_SHALLOW)')
  _WRAP_METHOD(std::vector< Glib::RefPtr<const Action> > get_actions() const, clutter_actor_get_actions)

  _WRAP_METHOD(bool has_actions() const, clutter_actor_has_actions)

  _WRAP_METHOD(void add_effect(const Glib::RefPtr<Effect>& effect), clutter_actor_add_effect)
  _WRAP_METHOD(void add_effect_with_name(const Glib::ustring& name, const Glib::RefPtr<Effect>& effect), clutter_actor_add_effect_with_name)
  _WRAP_METHOD(void remove_effect(const Glib::RefPtr<Effect>& effect), clutter_actor_remove_effect)
  _WRAP_METHOD(void remove_effect(const Glib::ustring& name), clutter_actor_remove_effect_by_name )

  #m4 _CONVERSION(`GList*',`std::vector< Glib::RefPtr<Effect> >',`Glib::ListHandler< Glib::RefPtr<Effect> >::list_to_vector($3, Glib::OWNERSHIP_SHALLOW)')
  _WRAP_METHOD(std::vector< Glib::RefPtr<Effect> > get_effects(), clutter_actor_get_effects)

  #m4 _CONVERSION(`GList*',`std::vector< Glib::RefPtr<const Effect> >',`Glib::ListHandler< Glib::RefPtr<const Effect> >::list_to_vector($3, Glib::OWNERSHIP_SHALLOW)')
  _WRAP_METHOD(std::vector< Glib::RefPtr<const Effect> > get_effects() const, clutter_actor_get_effects)

  _WRAP_METHOD(Glib::RefPtr<Effect> get_effect(const Glib::ustring& name), clutter_actor_get_effect, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Effect> get_effect(const Glib::ustring& name) const, clutter_actor_get_effect, refreturn, constversion)
  _WRAP_METHOD(void clear_effects(), clutter_actor_clear_effects)
  _WRAP_METHOD(bool has_effects() const, clutter_actor_has_effects)


  //Animation Framework.  The Easing state is used for basic animations.

  _WRAP_METHOD(void save_easing_state(), clutter_actor_save_easing_state)
  _WRAP_METHOD(void restore_easing_state(), clutter_actor_restore_easing_state)
  _WRAP_METHOD(void set_easing_duration(guint msecs), clutter_actor_set_easing_duration)
  _WRAP_METHOD(guint get_easing_duration() const, clutter_actor_get_easing_duration)
  _WRAP_METHOD(AnimationMode get_easing_mode() const, clutter_actor_get_easing_mode)
  _WRAP_METHOD(void set_easing_mode(AnimationMode mode), clutter_actor_set_easing_mode)
  _WRAP_METHOD(guint get_easing_delay() const, clutter_actor_get_easing_delay)
  _WRAP_METHOD(void set_easing_delay(guint msecs), clutter_actor_set_easing_delay)

  // Transitions.  Used for more complex animation handling.
  _WRAP_METHOD(Glib::RefPtr<Transition> get_transition(const Glib::ustring& name), clutter_actor_get_transition)
  _WRAP_METHOD(Glib::RefPtr<const Transition> get_transition(const Glib::ustring& name) const, clutter_actor_get_transition)

  _WRAP_METHOD(void add_transition(const Glib::ustring& name, const Glib::RefPtr<Transition>& transition),  clutter_actor_add_transition)
  _WRAP_METHOD(void remove_transition(const Glib::ustring& name), clutter_actor_remove_transition)
  _WRAP_METHOD(void remove_all_transitions(), clutter_actor_remove_all_transitions)

  //Constraints.
  _WRAP_METHOD(void add_constraint(const Glib::RefPtr<Constraint>& constraint), clutter_actor_add_constraint)
  _WRAP_METHOD(void add_constraint(const Glib::ustring& name, const Glib::RefPtr<Constraint>& constraint), clutter_actor_add_constraint_with_name )
  _WRAP_METHOD(void remove_constraint(const Glib::RefPtr<Constraint>& constraint), clutter_actor_remove_constraint)
  _WRAP_METHOD(void remove_constraint(const Glib::ustring& name), clutter_actor_remove_constraint_by_name)
  _WRAP_METHOD(bool has_constraints() const,  clutter_actor_has_constraints)

  // Clutter docs: Use g_list_free() when done.
  #m4 _CONVERSION(`GList*',`std::vector< Glib::RefPtr<Clutter::Constraint> >',`Glib::ListHandler< Glib::RefPtr<Clutter::Constraint> >::list_to_vector($3, Glib::OWNERSHIP_SHALLOW)')
  _WRAP_METHOD(std::vector< Glib::RefPtr<Clutter::Constraint> > get_constraints(), clutter_actor_get_constraints )
  #m4 _CONVERSION(`GList*',`std::vector< Glib::RefPtr<const Clutter::Constraint> >',`Glib::ListHandler< Glib::RefPtr<const Clutter::Constraint> >::list_to_vector($3, Glib::OWNERSHIP_SHALLOW)')
  _WRAP_METHOD(std::vector< Glib::RefPtr<const Clutter::Constraint> > get_constraints() const, clutter_actor_get_constraints)

  _WRAP_METHOD(Glib::RefPtr<const Constraint> get_constraint(const Glib::ustring& name) const, clutter_actor_get_constraint, refreturn, constversion)
  _WRAP_METHOD(Glib::RefPtr<Constraint> get_constraint(const Glib::ustring& name), clutter_actor_get_constraint, refreturn)
  _WRAP_METHOD(void clear_constraints(), clutter_actor_clear_constraints)



// signals
  _WRAP_SIGNAL(bool button_press_event(ButtonEvent* event), "button_press_event")
  _WRAP_SIGNAL(bool button_release_event(ButtonEvent* event), "button_release_event")
  _WRAP_SIGNAL(bool motion_event(MotionEvent* event), "motion_event")
  _WRAP_SIGNAL(bool leave_event(CrossingEvent* event), "leave_event")
  _WRAP_SIGNAL(void show(), "show")
  _WRAP_SIGNAL(void hide(), "hide")

  //We ignore the destroy signal because it would just encourage strange memory management.
  _IGNORE_SIGNAL(void destroy(), "destroy")

  _WRAP_SIGNAL(bool key_release_event(KeyEvent* event), "key_release_event")
  _WRAP_SIGNAL(bool enter_event(CrossingEvent* event), "enter_event")
  _WRAP_SIGNAL(bool event(Event* event), "event")
  _WRAP_SIGNAL(void key_focus_out(), "key-focus_out")
  _WRAP_SIGNAL(void key_focus_in(), "key-focus_in")
#m4 _CONVERSION(`ClutterActor*', `const Glib::RefPtr<Actor>&', `Glib::wrap(($3),true)')
  _WRAP_SIGNAL(void parent_set(const Glib::RefPtr<Actor>& old_parent), "parent_set")
  _WRAP_SIGNAL(bool scroll_event(ScrollEvent* event), "scroll_event")
  _WRAP_SIGNAL(bool key_press_event(KeyEvent* event), "key_press_event")
  _WRAP_SIGNAL(bool captured_event(Event* event), "captured_event")

  //We have to actually ignore this signal so we can replace its default signal handler with the vfunc.
  _IGNORE_SIGNAL("paint")
  //_WRAP_SIGNAL(void paint(), "paint", deprecated "Override the paint_func(), use a Clutter::Content implementation, or a Clutter::Effect instead of connecting to this signal.")

  _WRAP_SIGNAL(void queue_redaw(const Glib::RefPtr<Actor>& origin), "queue_redraw")
  _WRAP_SIGNAL(void queue_relayout(), "queue_relayout")
  _WRAP_SIGNAL(void realize(), "realize")
  _WRAP_SIGNAL(void unrealize(), "unrealize")

#m4 _CONVERSION(`const ClutterColor*', `const Color&', `Color(const_cast<ClutterColor*>($3), true)')
  _WRAP_SIGNAL(void pick(const Color& color), "pick")

#m4 _CONVERSION(`ClutterActorBox*', `const ActorBox&', `ActorBox(const_cast<ClutterActorBox*>($3))')
  _WRAP_SIGNAL(void allocation_changed(const ActorBox& box, AllocationFlags flags), "allocation-changed", no_default_handler)

  //TODO: Wrap ClutterTouchEvent?
  _WRAP_SIGNAL(bool touch_event(ClutterTouchEvent* event), "touch-event")

  //TODO: There might be a default handler when clutter breaks ABI:
  _WRAP_SIGNAL(void transitions_completed(), "transitions-completed", no_default_handler)
  _WRAP_SIGNAL(void transition_stopped(const Glib::ustring& name, bool is_finished), "transition-stopped", no_default_handler)

  _WRAP_PROPERTY("allocation", ActorBox)
  _WRAP_PROPERTY("anchor-x", float)
  _WRAP_PROPERTY("anchor-y", float)
  _WRAP_PROPERTY("anchor-gravity", Gravity)
  _WRAP_PROPERTY("background-color", Color)
  _WRAP_PROPERTY("background-color-set", bool)
  _WRAP_PROPERTY("child-transform", Matrix)
  _WRAP_PROPERTY("child-transform-set", bool)
  _WRAP_PROPERTY("clip", Geometry) //TODO: This is marked for removal in clutter.
  _WRAP_PROPERTY("clip-rect", Rect)
  _WRAP_PROPERTY("clip-to-allocation", bool)
  _WRAP_PROPERTY("content", Content)
  _WRAP_PROPERTY("content-box", ActorBox)
  _WRAP_PROPERTY("content-gravity", ContentGravity)
  _WRAP_PROPERTY("content-repeat", ContentRepeat)

  // This property is not wrapped because it is documented in Clutter as adding, instead of just setting, a Constraint.
  //_WRAP_PROPERTY("constraints", Glib::RefPtr<Constraint>)

  _WRAP_PROPERTY("depth", float)
  _WRAP_PROPERTY("effect", Glib::RefPtr<Effect>)
  _WRAP_PROPERTY("first-child", Glib::RefPtr<Actor>)
  _WRAP_PROPERTY("fixed-position-set", bool)
  _WRAP_PROPERTY("fixed-x", float)
  _WRAP_PROPERTY("fixed-y", float)
  _WRAP_PROPERTY("has-clip", bool)
  _WRAP_PROPERTY("has-pointer", bool)
  _WRAP_PROPERTY("height", float)
  _WRAP_PROPERTY("last-child", Glib::RefPtr<Actor>)
  _WRAP_PROPERTY("layout-manager", Glib::RefPtr<LayoutManager>)
  _WRAP_PROPERTY("magnification-filter", ScalingFilter)
  _WRAP_PROPERTY("mapped", bool)
  _WRAP_PROPERTY("margin-bottom", float)
  _WRAP_PROPERTY("margin-left", float)
  _WRAP_PROPERTY("margin-right", float)
  _WRAP_PROPERTY("margin-top", float)
  _WRAP_PROPERTY("minification-filter", ScalingFilter)
  _WRAP_PROPERTY("min-height", float)
  _WRAP_PROPERTY("min-height-set", bool)
  _WRAP_PROPERTY("min-width", float)
  _WRAP_PROPERTY("min-width-set", bool)
  _WRAP_PROPERTY("name", Glib::ustring)
  _WRAP_PROPERTY("natural-height", float)
  _WRAP_PROPERTY("natural-height-set", bool)
  _WRAP_PROPERTY("natural-width", float)
  _WRAP_PROPERTY("natural-width-set", bool)
  _WRAP_PROPERTY("opacity", guint8)
  _WRAP_PROPERTY("offscreen-redirect", OffscreenRedirect)
  _WRAP_PROPERTY("pivot-point", Point)
  _WRAP_PROPERTY("pivot-point-z", float)
  _WRAP_PROPERTY("position", Point)
  _WRAP_PROPERTY("reactive", bool)
  _WRAP_PROPERTY("realized", bool)
  _WRAP_PROPERTY("request-mode", RequestMode)
  _WRAP_PROPERTY("rotation-angle-x", double)
  _WRAP_PROPERTY("rotation-angle-y", double)
  _WRAP_PROPERTY("rotation-angle-z", double)
  _WRAP_PROPERTY("rotation-center-x", Vertex)
  _WRAP_PROPERTY("rotation-center-y", Vertex)
  _WRAP_PROPERTY("rotation-center-z", Vertex)
  _WRAP_PROPERTY("rotation-center-z-gravity", Gravity)
  _WRAP_PROPERTY("scale-x", double)
  _WRAP_PROPERTY("scale-y", double)
  _WRAP_PROPERTY("scale-z", double)
  _WRAP_PROPERTY("scale-center-x", double)
  _WRAP_PROPERTY("scale-center-y", double)
  _WRAP_PROPERTY("scale-gravity", Gravity)
  _WRAP_PROPERTY("show-on-set-parent", bool)
  //TODO: _WRAP_PROPERTY("size", Size)
  _WRAP_PROPERTY("text-direction", TextDirection)
  _WRAP_PROPERTY("translation_x", float)
  _WRAP_PROPERTY("translation_y", float)
  _WRAP_PROPERTY("translation_z", float)
  _WRAP_PROPERTY("transform", Matrix)
  _WRAP_PROPERTY("transform-set", bool)
  _WRAP_PROPERTY("visible", bool)
  _WRAP_PROPERTY("width", float)
  _WRAP_PROPERTY("x", float)
  _WRAP_PROPERTY("x-align", ActorAlign )
  _WRAP_PROPERTY("x-expand", bool)
  _WRAP_PROPERTY("y", float)
  _WRAP_PROPERTY("y-align", ActorAlign )
  _WRAP_PROPERTY("y-expand", bool)
  _WRAP_PROPERTY("z-position", float)

protected:
  //TODO: Wrap ClutterShaderEffect.
  _WRAP_METHOD(void set_shader_param_value(const Glib::ustring& param, const Glib::ValueBase& value),
               clutter_actor_set_shader_param, deprecated "Use ShaderEffect::set_uniform_value() instead.")

  //The show_all and hide_all vfuncs are deprecated.
  //_WRAP_VFUNC(void show_all(), show_all)
  //_WRAP_VFUNC(void hide_all(), hide_all)

  //The realize and unrealize vfuncs are deprecated.

  _WRAP_VFUNC(void map(), map)
  _WRAP_VFUNC(void unmap(), unmap)
  _WRAP_VFUNC(void paint(), paint)

  // TODO: I think we need to hand-code the vfuncs if we need to handle
  // the float* being NULL.
  #m4 _CONVERSION(`float*', `float&', `*($3)')
  #m4 _CONVERSION(`const ClutterActorBox*', `const ActorBox&', `Glib::wrap($3)')
  _WRAP_VFUNC(void get_preferred_width(float for_height, float& min_width_p, float& natural_width_p) const, get_preferred_width)
  _WRAP_VFUNC(void get_preferred_height(float for_width, float& min_height_p, float& natural_height_p) const, get_preferred_height)

  //TODO: Wrap this when clutter doesn't inappropriately compare function pointers:
  //See https://bugzilla.gnome.org/show_bug.cgi?id=763073#c6
  //_WRAP_VFUNC(void allocate(const ActorBox& box, AllocationFlags absolute_origin_changed), allocate)

  //TODO: Wrap this when clutter doesn't inappropriately compare function pointers:
  //See https://bugzilla.gnome.org/show_bug.cgi?id=763073#c6
  //_WRAP_VFUNC(void pick(const Color& color), pick)

  //TODO: _WRAP_VFUNC(Glib::RefPtr<Gtk::Object> get_accessible(), get_accessible)
  //TODO: Wrap ClutterPaintVolume?

  //TODO: Wrap this when clutter doesn't inappropriately compare function pointers:
  //See https://bugzilla.gnome.org/show_bug.cgi?id=763073#c6
  //_WRAP_VFUNC(bool get_paint_volume(ClutterPaintVolume* volume), get_paint_volume)

  _WRAP_VFUNC(bool has_overlaps() const, has_overlaps)

  //TODO: Wrap ClutterPaintNode*?
  _WRAP_VFUNC(void paint_node(ClutterPaintNode* root), paint_node)
};

_DEPRECATE_IFDEF_START
#ifndef DOXYGEN_SHOULD_SKIP_THIS
template <class ParamType>
void Actor::set_shader_param(const Glib::ustring& param, const ParamType& value)
{
  Glib::Value<ParamType> param_value;
  param_value.init(Glib::Value<ParamType>::value_type());

  param_value.set(value);
  this->set_shader_param_value(param, param_value);
}
#endif /* DOXYGEN_SHOULD_SKIP_THIS */
_DEPRECATE_IFDEF_END

} // namespace Clutter

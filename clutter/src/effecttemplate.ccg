/* Copyright (C) 2007 The cluttermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <clutter/clutter.h>

namespace Clutter
{

namespace
{

extern "C"
{

static guint32 c_alpha_callback(ClutterAlpha* alpha, gpointer user_data)
{
  try
  {
    EffectTemplate::SlotAlphaFunc* alpha_func = static_cast<EffectTemplate::SlotAlphaFunc*>(user_data);
    return (*alpha_func)(Glib::wrap(alpha, true));
  }
  catch (...)
  {
    Glib::exception_handlers_invoke();
  }
}

static void c_alpha_destroy_notify(gpointer data)
{
  try
  {
    delete static_cast<EffectTemplate::SlotAlphaFunc*>(data);
  }
  catch (...)
  {
    Glib::exception_handlers_invoke();
  }
}

} // extern "C"

// We use this helper class instead of the ClutterEffectCompleteFuncs
// because these don't have a GDestroyNotify.
struct CompleteCallback
{
  EffectTemplate::SlotEffectCompleteFunc func;

  static void create(const Glib::RefPtr<Timeline>& timeline, const Glib::RefPtr<Actor>& actor,
                     const EffectTemplate::SlotEffectCompleteFunc& func);
  static void on_callback(CompleteCallback* cb, const Glib::RefPtr<Actor>& actor);
};

void CompleteCallback::create(const Glib::RefPtr<Timeline>& timeline, const Glib::RefPtr<Actor>& actor,
                              const EffectTemplate::SlotEffectCompleteFunc& func)
{
  CompleteCallback *const cb = new CompleteCallback;
  cb->func = func;
  timeline->signal_completed().connect(sigc::bind(&CompleteCallback::on_callback, cb, actor));
}

void CompleteCallback::on_callback(CompleteCallback* cb, const Glib::RefPtr<Actor>& actor)
{
  cb->func(actor);
  // This causes the signal being disconnected from the timeline:
  delete cb;
}

} // anonymous namespace

EffectTemplate::EffectTemplate(const Glib::RefPtr<Timeline>& timeline,
                               const SlotAlphaFunc& alpha_func)
:
  _CONSTRUCT()
{
  clutter_effect_template_construct(gobj(), timeline->gobj(), &c_alpha_callback,
                                    new SlotAlphaFunc(alpha_func), &c_alpha_destroy_notify);
}

EffectTemplate::EffectTemplate(guint msecs, const SlotAlphaFunc& alpha_func)
:
  _CONSTRUCT()
{
  const Glib::RefPtr<Timeline> timeline = Timeline::create(msecs);
  clutter_effect_template_construct(gobj(), timeline->gobj(), &c_alpha_callback,
                                    new SlotAlphaFunc(alpha_func), &c_alpha_destroy_notify);
}

Glib::RefPtr<Timeline> EffectTemplate::fade(const Glib::RefPtr<Actor>& actor, guint8 opacity_end, const SlotEffectCompleteFunc& func)
{
  const Glib::RefPtr<Timeline> timeline = Glib::wrap(clutter_effect_fade(
      gobj(), actor->gobj(), opacity_end, 0, 0), true);
  if (!func.empty())
    CompleteCallback::create(timeline, actor, func);
  return timeline;
}

Glib::RefPtr<Timeline> EffectTemplate::depth(const Glib::RefPtr<Actor>& actor, int depth_end,
                                             const SlotEffectCompleteFunc& func)
{
  const Glib::RefPtr<Timeline> timeline = Glib::wrap(clutter_effect_depth(
      gobj(), actor->gobj(), depth_end, 0, 0), true);
  if (!func.empty())
    CompleteCallback::create(timeline, actor, func);
  return timeline;
}

Glib::RefPtr<Timeline> EffectTemplate::move(const Glib::RefPtr<Actor>& actor, int x, int y,
                                            const SlotEffectCompleteFunc& func)
{
  const Glib::RefPtr<Timeline> timeline = Glib::wrap(clutter_effect_move(
      gobj(), actor->gobj(), x, y, 0, 0), true);
  if (!func.empty())
    CompleteCallback::create(timeline, actor, func);
  return timeline;
}

Glib::RefPtr<Timeline> EffectTemplate::path(const Glib::RefPtr<Actor>& actor,
                                            const Glib::ArrayHandle<Knot>& knots,
                                            const SlotEffectCompleteFunc& func)
{
  // Note: Don't copy this code if you don't understand WHY the cast works here.
  const Glib::RefPtr<Timeline> timeline = Glib::wrap(clutter_effect_path(
      gobj(), actor->gobj(), reinterpret_cast<const ClutterKnot*>(knots.data()),
      knots.size(), 0, 0), true);
  if (!func.empty())
    CompleteCallback::create(timeline, actor, func);
  return timeline;
}

Glib::RefPtr<Timeline> EffectTemplate::scale(const Glib::RefPtr<Actor>& actor,
                                             double x_scale_end, double y_scale_end,
                                             const SlotEffectCompleteFunc& func)
{
  const Glib::RefPtr<Timeline> timeline = Glib::wrap(clutter_effect_scale(
      gobj(), actor->gobj(), x_scale_end, y_scale_end, 0, 0), true);
  if (!func.empty())
    CompleteCallback::create(timeline, actor, func);
  return timeline;
}

Glib::RefPtr<Timeline> EffectTemplate::rotate(const Glib::RefPtr<Actor>& actor, RotateAxis axis,
                                              double angle_end, int center_x, int center_y, int center_z,
                                              RotateDirection direction, const SlotEffectCompleteFunc& func)
{
  const Glib::RefPtr<Timeline> timeline = Glib::wrap(clutter_effect_rotate(
      gobj(), actor->gobj(), static_cast<ClutterRotateAxis>(axis), angle_end,
      center_x, center_y, center_z, static_cast<ClutterRotateDirection>(direction),
      0, 0), true);
  if (!func.empty())
    CompleteCallback::create(timeline, actor, func);
  return timeline;
}

} // namespace Clutter
